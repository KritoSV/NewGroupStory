# Большая шпаргалка по работке с *Git*, *Git Hub* и *MarkDown*
Оглавление:
1. Подготовка действий для работы с программами. --- **_Rustamoff_**
2. Работа с **_MarkDown_** Тонкости и плюсы. --- **__Shmid__**
3. Начало работы с **Git** в *Visual Studio Code* и немного магии. --- **_Fennellis_**
4. Основные команды в *Git*. --- **_Evgenichka_**
5. [Ветки в *Git* ветвление/слияние/конфликты.](#title5)
6. Начало работы в **_Git Hub_**. --- **_Osman_**
7. Работа с удалёнными репозотриями через локалный терминал. ---  **_AlekseyVahonin_**
8. Как работать в команде ***(Soft skill`s`)***, идеи и трудности. --- **_Sofyamamamia_** 
9. Основные ошибки при работе с *Git*, *Git Hub* и *MarkDown*. --- **_AlionaJe_** 
10. Немного о *Python* на *Vs Code* --- **_DEMS111_**


# <a id="title5">Глава 5. Ветки в *Git* Ветвление/Слияние/Конфликты.</a>

## **Основы ветвления**

Под веткой принято понимать независимую последовательность коммитов в хронологическом порядке. Однако конкретно в *Git* реализация ветки выполнена как указатель на последний коммит в рассматриваемой ветке. После создания ветки уже новый указатель ссылается на текущий коммит.

Имя основной ветки *Git* — проекта по умолчанию — *_master_* (однако зачастую бывает main, например, в *GitHub*), она появляется сразу при инициализации репозитория. Эта ветка ничем не отличается от остальных и также её можно переименовать, но по договоренности *master* принято считать главной веткой в проекте.

Команда **_git branch_** — главный инструмент для работы с ветвлением. С её помощью можно добавлять новые ветки, перечислять и переименовывать существующие и удалять их.

* Чтобы в *Git* добавить ветку мы используем:
    ***git branch** <имя ветки>*

После данной операции ветка уже была создана, но вы по-прежнему находитесь в прежней ветке. 
* Если вы планируете переместиться на другую ветку, в том числе только что созданную, необходимо написать: ***checkout: git checkout** <название ветки>*

Чаще всего при создании новой ветки git пользователю необходимо сразу же переключиться на нее. 
* В таком случае стоит использовать: **git checkout branch** <имя новой ветки>*

* Мы получим тот же результат при использовании *git checkout* с ключом *-b*: ***git checkout -b** <имя ветки>*

Если пользователю нужно получить список определенного множества веток, то тогда можно воспользоваться ключами. 

* Одними из самых распространенных будут:

*-r* — при использовании этого ключа мы получим **список удаленных веток**;

*-a* — используя этот параметр, в выводе будут **удаленные и локальные ветки**.

При выполнении этой команды *Git* требуется осуществить определенный порядок действий, чтобы переходить на ветку, которую мы указали. Для этого программа выполняет следующий алгоритм:

Проверка, что указанная нами ветка существует в проекте
Этот этап необходим, так как в ином случае программа не сможет переключиться на ветвь, которая не определена. Для большего понимания нужно вспомнить, что такое ветка в *git*. Учитываем, что фактически задание ветки — это запись коммита, на который она ссылается. Внутри *Git* наличие конкретной ветки проверяется наличием одноименного файла в конкретной директории.

Переключение указателя *HEAD* на новую ветку
Необходимо сместить указатель, чтобы *Git* понимал, где сейчас идет работа.

Изменение рабочей версии таким образом, чтобы новая ветка ей полностью соответствовала
Сама концепция работы ветвления заключается в том, что в разных ветках находятся разные версии кода, над которыми работа ведется отдельно друг от друга. Тогда необходимо изменить рабочую копию. *Git* берет последний коммит и восстанавливает все изменения.

После завершения всех перечисленных выше действий можно считать, что мы полностью переключились. Также с помощью *checkout* можно извлечь отдельный файл (или папку) из другой ветки и получить его, предварительно перейдя в ту ветку, куда вы собираетесь перенести файл. 
* Для этого выполняем: ***git checkout <имя новой ветки>** -- <Путь к папке>*

## *Основы слияния*
Ветвление позволяет разделять рабочий процесс, оптимизировать тестирование и написание нового кода. Однако после того, как разработчик убедился, что написанный им кусок кода готов и его можно отправить к остальной части итоговой версии, удобно переместить его в основную ветку. Такой подход дает возможность получить к концу разработки проекта целый продукт в одном месте.
Для этого в *Git* предусмотрено слияние — перенос изменений с одной ветки на другую. Однако сливаемая ветка (под этим определением мы подразумеваем ветку, у которой берем изменения для _«вливания»_ их в другую ветвь) никак не меняется и остается в прежнем состоянии. 
* Такие преобразования мы получаем, применив *git merge*:
***git merge** <имя сливаемой ветки>*

Операция может привести к появлению конфликтов при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния *Git* останавливает выполнение команды, чтобы вы могли разрешить конфликт.

Также стоит упомянуть о существовании ключей, предназначенных специально для работы с конфликтами:

* abort — прерывает слияние и возвращает все к началу
* continue — продолжает слияние после разрешения конфликта

Решить конфликт можно двумя способами:
1. Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.
2. Выбрать более подходящий файл, а от второго отказаться.


## *Конфликты слияния*
Системы контроля версий предназначены для управления дополнениями, вносимыми в проект множеством распределенных авторов (обычно разработчиков). Иногда один и тот же контент могут редактировать сразу несколько разработчиков. Если разработчик **A** попытается изменить код, который редактирует разработчик **B**, может произойти конфликт. Для предотвращения конфликтов разработчики работают в отдельных изолированных ветках. Основная задача команды *git merge* заключается в слиянии отдельных веток и разрешении любых конфликтующих правок.

Слияние и конфликты являются неотъемлемой частью работы с *Git*. В других инструментах управления версиями, например *SVN*, работа с конфликтами может быть дорогой и времязатратной. *Git* позволяет выполнять слияния очень просто. В большинстве случаев *Git* самостоятельно решает, как автоматически интегрировать новые изменения.

Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях *Git* не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. *Git* помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.

Конфликт во время слияния может произойти в двух отдельных точках — при запуске и во время процесса слияния. Далее рассмотрим, как разрешать каждый из этих конфликтных сценариев.

* ***Git* прерывает работу в самом начале слияния**

Выполнение команды слияния прерывается в самом начале, если *Git* обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. *Git* не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд *git stash*, *git checkout*, *git commit* или *git reset*. **Если команда слияния прерывается в самом начале, выдается следующее сообщение об ошибке: error: Entry '<fileName>' not uptodate. Cannot merge. (Changes in working directory)**

* ***Git* прерывает работу во время слияния**

Сбой **В ПРОЦЕССЕ** слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. *Git* сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы вы разрешили их вручную. **При сбое во время выполнения слияния выдается следующее сообщение об ошибке: error: Entry '<fileName>' would be overwritten by merge. Cannot merge. (Changes in staging area)**

## *Актуализация локального репозитория и контроль веток*

**_Git fetch_** — команда в распределенной системе контроля версий *Git*, которая используется для скачивания изменений из удаленного или локального репозитория в свой локальный репозиторий.

Польза *git fetch* в том, что эта команда привносит актуальность локальному репозиторию без изменения его дерева или текущей ветки. Таким образом, следить за изменениями, сделанными другими участниками, становится проще, быстрее можно начать работу с этими изменениями. 
Если Вы сталкиваетесь с трудностями привязки ветки вашего локального репозитория к удалённому, команда: *git fetch* обновит сведения об удалённом репозитории и в последствии вы сможете осуществить связку веток между собой. Для связи Вы можете использовать команду: **git branch --set-upstream-to=** имя репозитория/имя внешней ветки имя локальной ветки


* Чтобы удалить **локальную** ветку в *Git* нужно выполнить команду:

**_git branch -d_** имя ветки

Обратите внимание на то, что ветка, которую вы удаляете, не должна быть вашей текущей веткой, в которой вы работаете, иначе отобразится ошибка вида:
*error: Cannot delete branch ’mybranch’ checked out at ’/path/to*
Поэтому, если вам нужно удалить текущую ветку, то сначала нужно переключиться на какую-либо другую ветку, а только потом выполнять удаление.

Если вдруг возникает ошибка: *The branch ’mybranch’ is not fully merged. If you are sure you want to delete it* и вы по прежнему хотите удалить ветку, то для принудительного удаления ветки можно воспользоваться опцией **-D**:

**_git branch -D_** имя ветки

* Чтобы удалить **удаленную (находящуюся на удалённом репозитории)** ветку используется команда :

**_git push origin -d_** имя удалённой (*находящейся на удалённом репозитории*) ветки

На этом Мы заканчиваем знакомство с ветвлениями, слияниями и конфликтами.