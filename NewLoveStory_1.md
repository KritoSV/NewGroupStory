# Большая шпаргалка по работке с *Git*, *Git Hub* и *MarkDown*
Оглавление:
1. Подготовка действий для работы с программами. --- **_Rustamoff_**
2. [Работа с **_MarkDown_** Тонкости и плюсы.](#title2) --- **__Shmid__**
3. Начало работы с **Git** в *Visual Studio Code* и немного магии. --- **_Fennellis_**
4. Основные команды в *Git*. --- **_Evgenichka_**
5. [Ветки в *Git* ветвление/слияние/конфликты.](#title5)
6. Начало работы в **_Git Hub_**. --- **_Osman_**
7. Работа с удалёнными репозотриями через локалный терминал. ---  **_AlekseyVahonin_**
8. Как работать в команде ***(Soft skill`s`)***, идеи и трудности. --- **_Sofyamamamia_** 
9. Основные ошибки при работе с *Git*, *Git Hub* и *MarkDown*. --- **_AlionaJe_** 
10. Немного о *Python* на *Vs Code* --- **_DEMS111_**

## <a id="title2"> Глава 2. Работа с **_MarkDown_** Тонкости и плюсы.</a>

Исходный синтаксис **Markdown**, опубликованный **Джоном Грубером**, добавил несколько важных элементов для редактирования документов, но некоторые пользователи остались недовольны.

Расширенный синтаксис пытается решить эту проблему, добавляя новые элементы с помощью новой маркировки.

Таблицы, блоки кода, автоматическая генерация links и даже сноски являются примерами расширения базового синтаксиса Markdown.

Эти элементы можно активировать, установив plugin для вашего процессора Markdown или даже используя небольшой вариант синтаксиса языка.

>**ПРИМЕЧАНИЕ**: вполне возможно, что ваше приложение Markdown уже поддерживает элементы, представленные в этой статье, поэтому стоит протестировать каждый из них, следуя руководству.

Маркдаун – облегченный язык разметки, созданный для написания, чтения, оформления веб-текстов.

Частично или полностью язык поддерживается многими проектами:
 * CMS и блог-платформами (Drupal, Ghost, Medium);
 * крупнейшими хранилищами контента (GitHub, Microsoft Docs);
 * мессенджерами (Telegram, Slack);
 * текстовыми редакторами (Atom, iA Writer, Typora);
 * сервисами для проджект-менеджмента (Todoist, Trello).
 * 
### Разделим тему на основные моменты :

#### **1** - Заголовки и горизонтальные линии
#### **2** - Выделения текста
#### **3** - Списки и отступы
#### **4** - Ссылки и картинки
#### **5** - Цитаты и вставки кода
#### **6** - Таблицы и чек-боксы
#### **7** - Важно: экранирование
#### **8** - Инструменты для работы с маркдаун-разметкой

#### Заголовки и горизонтальные линии

Заголовки H1–H6 выделяются в Markdown с помощью знаков решетки (диез/шарп). Можно просто поставить нужное количество решеток в начале строки, чтобы указать уровень. Или заключить строку с двух сторон по аналогии с HTML-тегами, кому как удобно.
Другой вариант: написать текст первого заголовка, затем нажать Enter и на следующей строке указать любое количество знаков «равно». Аналогичным образом можно выделить H2, только использовать уже нужно дефисы. Заголовки других уровней таким методом оформить нельзя .

==вставить фото==

# Это H1

## Это H2 ##

### Это H3

#### Это H4 ####

##### Это H5 #####

###### Это H6
Это H1 или Заголовок 1
====
Это H2 или Заголовок 2
----
Если отделить последовательность дефисов пустой строкой, то H2 не будет. Получится горизонтальная разделительная линия. Ее можно оформить также с помощью звездочек или знака нижнего подчеркивания. Количество символов и пробелов между ними роли не играет. А вот знак равенства работает только с заголовками H1, горизонтальные линии он не рисует: 

==вставить фото==

- - -
* * * * 
____
****
---- --- ---
**** * ** ******
===
----

#### Выделения текста

Форматирование курсивом и жирным точно есть во всех инструментах, где другие функции Markdown могут быть ограничены. Синтаксис выделения текста и расставления акцентов:

==вставить фото== 

__Жирный__

**Тоже жирный**

*Курсив*

_Тоже курсив_

~~Зачеркнутый~~

**_Жирный курсив_**

~~_Зачеркнутый курсив_~~

~~__Зачеркнутый жирный__~~

Можно легко комбинировать эти способы выделения.

#### Списки и отступы

Чтобы оформить строку в элемент маркированного списка, в начале нужно поставить плюс, минус или звездочку. Звездочка не приведет к курсивному выделению, потому что отделяется от слова пробелом.

==вставить фото==

- Пункт 1

- Пункт 2

- Пункт 3

или

+ Пункт 1

+ Пункт 2

+ Пункт 3

или

* Пункт 1

* Пункт 2

* Пункт 3
  
Если необходимо создать нумерованный список, используйте в начале строки цифру с точкой. Удобно, что нумерация автоматическая: можно вставить любые цифры, и ошибки не будет.

==вставить фото==

1. Пункт 1

2. Пункт 2

3. Пункт 3

или

1. Пункт 1

1. Пункт 2

1. Пункт 3

или даже

9. Пункт 1

5. Пункт 2

1. Пункт 3

Маркдаун-разметка также позволяет оформлять многоуровневые списки. Уровень обозначается не количеством спецсимволов, как в случае с заголовками, а за счет отступов. Проще не считать пробелы, а каждый новый подпункт выделять табуляцией.

==вставить фото==

- Пункт 1

        - Подпункт A

                - Подподпункт a

- Пункт 2

        + Подпункт A

                * Подподпункт a

---

1. Пункт 1

        + Подпункт A

                - Подподпункт a

2. Пункт 2

        1. Подпункт 2.1.

                1. Подподпункт 2.1.1

3. Пункт 3

Если пункт списка включает несколько строк или абзацев, нужно соблюдать всё те же отступы, чтобы было красиво оформлено. Ключевые мысли в списках также можно выделять другой разметкой, например, жирным. Примеры:

==вставить фото==

* __Тезис №1__

    Раскрываем тезис.

* __Тезис №2__

    Раскрываем тезис.

---

* __Тезис №1__ Раскрываем тезис.

* __Тезис №2__ Раскрываем тезис.

#### Ссылки и картинки

Чтобы поставить гиперссылку без анкора, нужно взять URL в угловые скобки. С e-mail – аналогично.

Если вставлять с анкором, то тогда текст ссылки заключается в квадратные скобки, а адрес страницы – в круглые. Рядом с URL можно прописать тайтл, его объявляют в кавычках (он тоже остается внутри круглых скобок).

==вставить фото==

Это [ссылка]( "Агентство TexTerra") с тайтлом.

[Эта ссылка](http://example.net/) без заголовка.

<https://texterra.ru/&gt; – а это безанкорная ссылка.

Чтобы длинные URL не затрудняли чтение и написание документа Markdown, есть вариант присвоения каждой ссылке определенных ID (меток/переменных). Можно сделать это несколькими способами:

Ссылаемся на [блог TexTerra][tt-blog-link] через ID. Объявляем метку позже по аналогии со сносками. Цифрами обозначить тоже можно: [Google][1], [Yandex][2]

Еще можно так встраивать ссылки: [TexTerra] []

[tt-blog-link]: /blog "Блог про интернет-маркетинг"

[1]: google.com 'Сайт Google'

[2]: yandex.ru (Сайт «Яндекса»)

[TexTerra]:

==вставить фото==

Если URL длинные, да еще и с UTM-метками, их лучше спрятать в самый конец документа. Обратите внимание: тайтлы можно обозначить и двойными, и одинарными кавычками, а также в скобкахСинтаксис Markdown для работы с картинками очень похожий. Разница в восклицательном знаке перед первыми квадратными скобками. Ссылке на картинку тоже можно присвоить определенный ID. Примеры:

==вствить фото==

![Лого TexTerra](/upload/firmenniy-stil/footer-logo-svg.svg)

---

![Лого TexTerra](/upload/firmenniy-stil/footer-logo-svg.svg "Наш логотип")

---

![Картинка][logo]

[logo]: /upload/firmenniy-stil/footer-logo-svg.svg "Наш логотип"

#### Цитаты и вставки кода

Если безанкорные ссылки оформляются двумя угловыми скобками, то для цитаты нужна только одна такая скобка. Все очень просто:

==вставить фото==

> Привет! Это цитата

> Это тоже цитата

> Это еще одна цитата

Это ее продолжение (показываем отступом)

> Это тоже

Будет

>

> Одна целая цитата

Цитаты вкладываются как в списки, так и в другие цитаты. Цитаты также могут включать в себя заголовки, списки и код.

==вставить фото==

Кстати, о коде. Вставлять его можно как внутрь строк, так и отдельными блоками. Для соответствующей разметки используют грависы или обратные тики. Инлайн-код выделяют одиночными символами, а блоки – тройными. При оформлении целого блока можно указать язык программирования, чтобы подсветить соответствующий синтаксис. Примеры:

==вставить фото==

Просто инлайн-код: `print("Hello, World!")`

Код на Python:

```python

x = int(input())

if x > 0:

    print(x)

else:

    print(-x)

```

Код на JavaScript:

```javascript

let greeting1 = 'Father!';

console.log(greeting1);

let greeting2 = 'Mother!';

console.log(greeting2);

```

#### Таблицы и чек-боксы

Если поддерживается расширенная версия Markdown, можно вставлять таблицы. Для этого используются всего два символа: вертикальная черта и дефис. Дефисы работают примерно так же, как в случае с горизонтальной линией: отделяют заголовки от других строк, при этом количество символов значения не имеет. Вертикальная черта служит границей между столбцами.

Пример – таблица меток для блоков кода, об этом было в предыдущем разделе:

==вставить фото==

| Язык | Метка |
| -----|------|
| Java Script | javascript |
| C++ |cpp|
| HTML|html|
|Markdown|md|
|JSON|json|
|Python|python|
|SQL|sql|

Для любителей чек-листов есть такая возможность. Чек-бокс получится, если в начале строки вставить пробел, заключенный с двух сторон в квадратные скобки. Можно сразу задать выполненную задачу с помощью [X]. С оформлением ссылок по-другому – в квадратных скобках или текст, или ничего.

==вставить фото==
[] взять кошелек

#### Важно: экранирование

Мы разобрали с десяток различных символов, которые используются в разметке Markdown. Но что если эти символы нужны нам в самом тексте? Чтобы спецсимволы не исчезали и не влияли на оформление, нужно использовать экранирование. Как и во многих других языках программирования, этим целям служит обратная косая черта (бэкслеш)

==вставить фото==

Исключение – когда надо вставить внутри кода грависы (обратные тики). Интерпретатор не посчитает их за обозначение инлайн-кода, если только весь участок кода заключен с двух сторон в двойные грависы. Ничего не понятно? На примере все наглядно:

==вставить фото==

В отличие от HTML, в Markdown не нужно специально экранировать амперсанд (&) или угловую скобку (<).

# <a id="title5">Глава 5. Ветки в *Git* Ветвление/Слияние/Конфликты.</a>

## **Основы ветвления**

Под веткой принято понимать независимую последовательность коммитов в хронологическом порядке. Однако конкретно в *Git* реализация ветки выполнена как указатель на последний коммит в рассматриваемой ветке. После создания ветки уже новый указатель ссылается на текущий коммит.

Имя основной ветки *Git* — проекта по умолчанию — *_master_* (однако зачастую бывает main, например, в *GitHub*), она появляется сразу при инициализации репозитория. Эта ветка ничем не отличается от остальных и также её можно переименовать, но по договоренности *master* принято считать главной веткой в проекте.

Команда **_git branch_** — главный инструмент для работы с ветвлением. С её помощью можно добавлять новые ветки, перечислять и переименовывать существующие и удалять их.

* Чтобы в *Git* добавить ветку мы используем:
    ***git branch** <имя ветки>*

После данной операции ветка уже была создана, но вы по-прежнему находитесь в прежней ветке. 
* Если вы планируете переместиться на другую ветку, в том числе только что созданную, необходимо написать: ***checkout: git checkout** <название ветки>*

Чаще всего при создании новой ветки git пользователю необходимо сразу же переключиться на нее. 
* В таком случае стоит использовать: **git checkout branch** <имя новой ветки>*

* Мы получим тот же результат при использовании *git checkout* с ключом *-b*: ***git checkout -b** <имя ветки>*

Если пользователю нужно получить список определенного множества веток, то тогда можно воспользоваться ключами. 

* Одними из самых распространенных будут:

*-r* — при использовании этого ключа мы получим **список удаленных веток**;

*-a* — используя этот параметр, в выводе будут **удаленные и локальные ветки**.

При выполнении этой команды *Git* требуется осуществить определенный порядок действий, чтобы переходить на ветку, которую мы указали. Для этого программа выполняет следующий алгоритм:

Проверка, что указанная нами ветка существует в проекте
Этот этап необходим, так как в ином случае программа не сможет переключиться на ветвь, которая не определена. Для большего понимания нужно вспомнить, что такое ветка в *git*. Учитываем, что фактически задание ветки — это запись коммита, на который она ссылается. Внутри *Git* наличие конкретной ветки проверяется наличием одноименного файла в конкретной директории.

Переключение указателя *HEAD* на новую ветку
Необходимо сместить указатель, чтобы *Git* понимал, где сейчас идет работа.

Изменение рабочей версии таким образом, чтобы новая ветка ей полностью соответствовала
Сама концепция работы ветвления заключается в том, что в разных ветках находятся разные версии кода, над которыми работа ведется отдельно друг от друга. Тогда необходимо изменить рабочую копию. *Git* берет последний коммит и восстанавливает все изменения.

После завершения всех перечисленных выше действий можно считать, что мы полностью переключились. Также с помощью *checkout* можно извлечь отдельный файл (или папку) из другой ветки и получить его, предварительно перейдя в ту ветку, куда вы собираетесь перенести файл. 
* Для этого выполняем: ***git checkout <имя новой ветки>** -- <Путь к папке>*

## *Основы слияния*
Ветвление позволяет разделять рабочий процесс, оптимизировать тестирование и написание нового кода. Однако после того, как разработчик убедился, что написанный им кусок кода готов и его можно отправить к остальной части итоговой версии, удобно переместить его в основную ветку. Такой подход дает возможность получить к концу разработки проекта целый продукт в одном месте.
Для этого в *Git* предусмотрено слияние — перенос изменений с одной ветки на другую. Однако сливаемая ветка (под этим определением мы подразумеваем ветку, у которой берем изменения для _«вливания»_ их в другую ветвь) никак не меняется и остается в прежнем состоянии. 
* Такие преобразования мы получаем, применив *git merge*:
***git merge** <имя сливаемой ветки>*

Операция может привести к появлению конфликтов при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния *Git* останавливает выполнение команды, чтобы вы могли разрешить конфликт.

Также стоит упомянуть о существовании ключей, предназначенных специально для работы с конфликтами:

* abort — прерывает слияние и возвращает все к началу
* continue — продолжает слияние после разрешения конфликта

Решить конфликт можно двумя способами:
1. Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.
2. Выбрать более подходящий файл, а от второго отказаться.


## *Конфликты слияния*
Системы контроля версий предназначены для управления дополнениями, вносимыми в проект множеством распределенных авторов (обычно разработчиков). Иногда один и тот же контент могут редактировать сразу несколько разработчиков. Если разработчик **A** попытается изменить код, который редактирует разработчик **B**, может произойти конфликт. Для предотвращения конфликтов разработчики работают в отдельных изолированных ветках. Основная задача команды *git merge* заключается в слиянии отдельных веток и разрешении любых конфликтующих правок.

Слияние и конфликты являются неотъемлемой частью работы с *Git*. В других инструментах управления версиями, например *SVN*, работа с конфликтами может быть дорогой и времязатратной. *Git* позволяет выполнять слияния очень просто. В большинстве случаев *Git* самостоятельно решает, как автоматически интегрировать новые изменения.

Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях *Git* не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. *Git* помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.

Конфликт во время слияния может произойти в двух отдельных точках — при запуске и во время процесса слияния. Далее рассмотрим, как разрешать каждый из этих конфликтных сценариев.

* ***Git* прерывает работу в самом начале слияния**

Выполнение команды слияния прерывается в самом начале, если *Git* обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. *Git* не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд *git stash*, *git checkout*, *git commit* или *git reset*. **Если команда слияния прерывается в самом начале, выдается следующее сообщение об ошибке: error: Entry '<fileName>' not uptodate. Cannot merge. (Changes in working directory)**

* ***Git* прерывает работу во время слияния**

Сбой **В ПРОЦЕССЕ** слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. *Git* сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы вы разрешили их вручную. **При сбое во время выполнения слияния выдается следующее сообщение об ошибке: error: Entry '<fileName>' would be overwritten by merge. Cannot merge. (Changes in staging area)**

## *Актуализация локального репозитория и контроль веток*

**_Git fetch_** — команда в распределенной системе контроля версий *Git*, которая используется для скачивания изменений из удаленного или локального репозитория в свой локальный репозиторий.

Польза *git fetch* в том, что эта команда привносит актуальность локальному репозиторию без изменения его дерева или текущей ветки. Таким образом, следить за изменениями, сделанными другими участниками, становится проще, быстрее можно начать работу с этими изменениями. 
Если Вы сталкиваетесь с трудностями привязки ветки вашего локального репозитория к удалённому, команда: *git fetch* обновит сведения об удалённом репозитории и в последствии вы сможете осуществить связку веток между собой. Для связи Вы можете использовать команду: **git branch --set-upstream-to=** имя репозитория/имя внешней ветки имя локальной ветки


* Чтобы удалить **локальную** ветку в *Git* нужно выполнить команду:

**_git branch -d_** имя ветки

Обратите внимание на то, что ветка, которую вы удаляете, не должна быть вашей текущей веткой, в которой вы работаете, иначе отобразится ошибка вида:
*error: Cannot delete branch ’mybranch’ checked out at ’/path/to*
Поэтому, если вам нужно удалить текущую ветку, то сначала нужно переключиться на какую-либо другую ветку, а только потом выполнять удаление.

Если вдруг возникает ошибка: *The branch ’mybranch’ is not fully merged. If you are sure you want to delete it* и вы по прежнему хотите удалить ветку, то для принудительного удаления ветки можно воспользоваться опцией **-D**:

**_git branch -D_** имя ветки

* Чтобы удалить **удаленную (находящуюся на удалённом репозитории)** ветку используется команда :

**_git push origin -d_** имя удалённой (*находящейся на удалённом репозитории*) ветки

На этом Мы заканчиваем знакомство с ветвлениями, слияниями и конфликтами.