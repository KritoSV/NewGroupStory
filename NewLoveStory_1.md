# Большая шпаргалка по работке с *Git*, *Git Hub* и *MarkDown*
Оглавление:
1. Подготовка действий для работы с программами. --- **_Rustamoff_**
2. [Работа с **_MarkDown_** Тонкости и плюсы.](#title2) --- **__Shmid__**
3. Начало работы с **Git** в *Visual Studio Code* и немного магии. --- **_Fennellis_**
4. Основные команды в *Git*. --- **_Evgenichka_**
5. [Ветки в *Git* ветвление/слияние/конфликты.](#title5)
6. Начало работы в **_Git Hub_**. --- **_Osman_**
7. Работа с удалёнными репозотриями через локалный терминал. ---  **_AlekseyVahonin_**
8. Как работать в команде ***(Soft skill`s`)***, идеи и трудности. --- **_Sofyamamamia_** 
9. Основные ошибки при работе с *Git*, *Git Hub* и *MarkDown*. --- **_AlionaJe_** 
10. Немного о *Python* на *Vs Code* --- **_DEMS111_**

## <a id="title2"> Глава 2. Работа с **_MarkDown_** Тонкости и плюсы.</a>

Исходный синтаксис **Markdown**, опубликованный **Джоном Грубером**, добавил несколько важных элементов для редактирования документов, но некоторые пользователи остались недовольны.

Расширенный синтаксис пытается решить эту проблему, добавляя новые элементы с помощью новой маркировки.

Таблицы, блоки кода, автоматическая генерация links и даже сноски являются примерами расширения базового синтаксиса **Markdown**.

Эти элементы можно активировать, установив plugin для вашего процессора Markdown или даже используя небольшой вариант синтаксиса языка.

>**ПРИМЕЧАНИЕ**: вполне возможно, что ваше приложение *Markdown* уже поддерживает элементы, представленные в этой статье, поэтому стоит протестировать каждый из них, следуя руководству.

Маркдаун – облегченный язык разметки, созданный для написания, чтения, оформления веб-текстов.

Частично или полностью язык поддерживается многими проектами:
 * CMS и блог-платформами (__Drupal, Ghost, Medium__);
 * крупнейшими хранилищами контента (__GitHub, Microsoft Docs__);
 * мессенджерами (__Telegram, Slack__);
 * текстовыми редакторами (__Atom, iA Writer, Typora__);
 * сервисами для проджект-менеджмента (__Todoist, Trello__).
 
### Разделим тему на основные моменты :

#### **1** - [Заголовки и горизонтальные линии](#title100)
#### **2** - [Выделения текста](#title101)
#### **3** - [Списки и отступы](#title102)
#### **4** - [Ссылки и картинки](#title103)
#### **5** - [Цитаты и вставки кода](#title104)
#### **6** - [Таблицы и чек-боксы](#title105)
#### **7** - [Важно: экранирование](#title106)
#### **8** - [Инструменты для работы с маркдаун-разметкой](#title107)

#### <a id="title100">Заголовки и горизонтальные линии</a>

Заголовки H1–H6 выделяются в Markdown с помощью знаков решетки (диез/шарп). Можно просто поставить нужное количество решеток в начале строки, чтобы указать уровень. Или заключить строку с двух сторон по аналогии с HTML-тегами, кому как удобно.
Другой вариант: написать текст первого заголовка, затем нажать Enter и на следующей строке указать любое количество знаков «равно». Аналогичным образом можно выделить H2, только использовать уже нужно дефисы. Заголовки других уровней таким методом оформить нельзя .

![](https://sun9-20.userapi.com/impg/VGJLqwLAoacUC9PWP2fXkBdrThoq2f-sdWyLHg/PV0P6thWgSI.jpg?size=2560x902&quality=95&sign=da81074bb68eabf1a855936b66ddba60&type=album)

Если отделить последовательность дефисов пустой строкой, то H2 не будет. Получится горизонтальная разделительная линия. Ее можно оформить также с помощью звездочек или знака нижнего подчеркивания. Количество символов и пробелов между ними роли не играет. А вот знак равенства работает только с заголовками H1, горизонтальные линии он не рисует: 

![](https://sun9-26.userapi.com/impg/IinbaXosxxcLcu4AkIfpJwUBcpKGX4VuTQ1aSg/fKjaQHhhir0.jpg?size=2560x545&quality=95&sign=5c3998dd3e2df212ed07b49c1ee30865&type=album)

#### <a id="title101">Выделения текста</a>

Форматирование курсивом и жирным точно есть во всех инструментах, где другие функции Markdown могут быть ограничены. Синтаксис выделения текста и расставления акцентов:

![](https://sun9-38.userapi.com/impg/NZCz9Qt_CFjX48VZXOZQPVzRstryw3-qj2s3UA/dXGko-uYRYo.jpg?size=2560x945&quality=95&sign=ed225bdaf170dbfbb17d30a1257b68e1&type=album)

Можно легко комбинировать эти способы выделения.

#### <a id="title102">Списки и отступы</a>

Чтобы оформить строку в элемент маркированного списка, в начале нужно поставить плюс, минус или звездочку. Звездочка не приведет к курсивному выделению, потому что отделяется от слова пробелом.

![](https://sun9-9.userapi.com/impg/p1rsrzA1t4WmDGPVqAly4IpNTvfQWDiCsVyneg/FoISLR8Dx2s.jpg?size=2560x941&quality=95&sign=014ddae91a2520ba8d573b90d47cc41d&type=album)

Если необходимо создать нумерованный список, используйте в начале строки цифру с точкой. Удобно, что нумерация автоматическая: можно вставить любые цифры, и ошибки не будет.

![](https://sun9-37.userapi.com/impg/CAkOoP-Sy56VF9kSMjeQGBhbOAqq_AngDs6gyQ/YIEjcUIdd0Y.jpg?size=2560x934&quality=95&sign=0028f4e1a83e25f4ad1bdf7d1885f1fb&type=album)

Маркдаун-разметка также позволяет оформлять многоуровневые списки. Уровень обозначается не количеством спецсимволов, как в случае с заголовками, а за счет отступов. Проще не считать пробелы, а каждый новый подпункт выделять табуляцией.

![](https://sun9-19.userapi.com/impg/QCtYYRxisyK3EjSGh70fryy3B_k2pG5Zfa12Uw/qlWgp_fi8J8.jpg?size=2560x1163&quality=95&sign=0b6dbcfb6c3f90567d48c3fe85b22b91&type=album)

Если пункт списка включает несколько строк или абзацев, нужно соблюдать всё те же отступы, чтобы было красиво оформлено. Ключевые мысли в списках также можно выделять другой разметкой, например, жирным. Примеры:

![](https://sun9-70.userapi.com/impg/xqE7UtfnLvPeRI7m29ZCoJEWivRqdvk_6NrdvQ/QkkRf0Qm1Xc.jpg?size=2560x561&quality=95&sign=89c3eb5e4776bd789414be9547b20a63&type=album)

#### <a id="title104">Ссылки и картинки</a>

Чтобы поставить гиперссылку без анкора, нужно взять URL в угловые скобки. С e-mail – аналогично.

Если вставлять с анкором, то тогда текст ссылки заключается в квадратные скобки, а адрес страницы – в круглые. Рядом с URL можно прописать тайтл, его объявляют в кавычках (он тоже остается внутри круглых скобок).

![](https://sun9-79.userapi.com/impg/iBySIIPWaVD9gNF5ByZHywNrF9QoCHbUV9glvw/9PfZl1zOlc8.jpg?size=2560x556&quality=95&sign=ab13f3d4c91e9e68cb66fec668a96ce3&type=album)

Чтобы длинные URL не затрудняли чтение и написание документа Markdown, есть вариант присвоения каждой ссылке определенных ID (меток/переменных). Можно сделать это несколькими способами:

![](https://sun9-35.userapi.com/impg/v47P69l5yD4G-rweWFDu_KLyFWsqaOOw4VggLA/pgKjRhzN_3M.jpg?size=2560x758&quality=95&sign=3002544c2f99bde9ea2c56f3b8643709&type=album)

Если URL длинные, да еще и с UTM-метками, их лучше спрятать в самый конец документа. Обратите внимание: тайтлы можно обозначить и двойными, и одинарными кавычками, а также в скобкахСинтаксис Markdown для работы с картинками очень похожий. Разница в восклицательном знаке перед первыми квадратными скобками. Ссылке на картинку тоже можно присвоить определенный ID. Примеры:

![](https://sun9-30.userapi.com/impg/nbdOL9_mzVBiviUtpXXO-K1IS4Vt_gYUq2uMMA/qm0ex2l-8EA.jpg?size=2560x890&quality=95&sign=3591a2ebf8216ff98ecbd8ae7542ea02&type=album)

#### <a id="title105">Цитаты и вставки кода</a>

Если безанкорные ссылки оформляются двумя угловыми скобками, то для цитаты нужна только одна такая скобка. Все очень просто:

![](https://sun9-17.userapi.com/impg/DFY4F_Pq_I5Z7tnlRX6SD0wVS6eYxtw_nOMbyw/qEXnEy8b6zk.jpg?size=2560x725&quality=95&sign=b9886a6d8d37ab89daa51d49c4a268d4&type=album)

Цитаты вкладываются как в списки, так и в другие цитаты. Цитаты также могут включать в себя заголовки, списки и код.

![](https://sun9-20.userapi.com/impg/KHdB272oe-d-BFKppV4AcTV3S_DhGevqXUiD6g/U-jM1wonYcw.jpg?size=2560x500&quality=95&sign=15f39078070164e234fb305588ae84f0&type=album)

Кстати, о коде. Вставлять его можно как внутрь строк, так и отдельными блоками. Для соответствующей разметки используют грависы или обратные тики. Инлайн-код выделяют одиночными символами, а блоки – тройными. При оформлении целого блока можно указать язык программирования, чтобы подсветить соответствующий синтаксис. Примеры:

![](https://sun9-24.userapi.com/impg/WNMxUPALlgo8tfB2Z3KEhumadXuQjTIzpVcMyA/ak_3UmfIs-w.jpg?size=2560x1100&quality=95&sign=3f01353e0ae26f6ba57680bcce8a9813&type=album)

#### <a id="title6">Таблицы и чек-боксы</a>

Если поддерживается расширенная версия Markdown, можно вставлять таблицы. Для этого используются всего два символа: вертикальная черта и дефис. Дефисы работают примерно так же, как в случае с горизонтальной линией: отделяют заголовки от других строк, при этом количество символов значения не имеет. Вертикальная черта служит границей между столбцами.

Пример – таблица меток для блоков кода, об этом было в предыдущем разделе:

![](https://sun9-3.userapi.com/impg/BQTTaks9X1h1_8PHFLP_1XNAfCjhpcA-wLeSFg/_V5mtA-CIOA.jpg?size=2560x720&quality=95&sign=a751fa2bf181f980b0a415363c926713&type=album)

Для любителей чек-листов есть такая возможность. Чек-бокс получится, если в начале строки вставить пробел, заключенный с двух сторон в квадратные скобки. Можно сразу задать выполненную задачу с помощью [X]. С оформлением ссылок по-другому – в квадратных скобках или текст, или ничего.

#### <a id="title107">Важно: экранирование</a>

Мы разобрали с десяток различных символов, которые используются в разметке Markdown. Но что если эти символы нужны нам в самом тексте? Чтобы спецсимволы не исчезали и не влияли на оформление, нужно использовать экранирование. Как и во многих других языках программирования, этим целям служит обратная косая черта (бэкслеш)

![](https://sun9-36.userapi.com/impg/gJt9qMz1CnGsGI18ERSpdtC_pAplcdbtSLaw-A/nWgHuKDvoz0.jpg?size=2560x323&quality=95&sign=f90a2b053f4d2b74ec4e7667917fd2ca&type=album)

Исключение – когда надо вставить внутри кода грависы (обратные тики). Интерпретатор не посчитает их за обозначение инлайн-кода, если только весь участок кода заключен с двух сторон в двойные грависы. Ничего не понятно? На примере все наглядно:

![](https://sun9-63.userapi.com/impg/kix2VRa2oA7PpMfaaq9NgXAoUJDtKwupsoQA2w/TSGe7duDggk.jpg?size=2560x334&quality=95&sign=20e8ea89ca650fdef63b73f369d1e9be&type=album)

В отличие от HTML, в Markdown не нужно специально экранировать амперсанд (&) или угловую скобку (<).

# <a id="title5">Глава 5. Ветки в *Git* Ветвление/Слияние/Конфликты.</a>

## **Основы ветвления**

Под веткой принято понимать независимую последовательность коммитов в хронологическом порядке. Однако конкретно в *Git* реализация ветки выполнена как указатель на последний коммит в рассматриваемой ветке. После создания ветки уже новый указатель ссылается на текущий коммит.

Имя основной ветки *Git* — проекта по умолчанию — *_master_* (однако зачастую бывает main, например, в *GitHub*), она появляется сразу при инициализации репозитория. Эта ветка ничем не отличается от остальных и также её можно переименовать, но по договоренности *master* принято считать главной веткой в проекте.

Команда **_git branch_** — главный инструмент для работы с ветвлением. С её помощью можно добавлять новые ветки, перечислять и переименовывать существующие и удалять их.

* Чтобы в *Git* добавить ветку мы используем:
    ***git branch** <имя ветки>*

После данной операции ветка уже была создана, но вы по-прежнему находитесь в прежней ветке. 
* Если вы планируете переместиться на другую ветку, в том числе только что созданную, необходимо написать: ***checkout: git checkout** <название ветки>*

Чаще всего при создании новой ветки git пользователю необходимо сразу же переключиться на нее. 
* В таком случае стоит использовать: **git checkout branch** <имя новой ветки>*

* Мы получим тот же результат при использовании *git checkout* с ключом *-b*: ***git checkout -b** <имя ветки>*

Если пользователю нужно получить список определенного множества веток, то тогда можно воспользоваться ключами. 

* Одними из самых распространенных будут:

*-r* — при использовании этого ключа мы получим **список удаленных веток**;

*-a* — используя этот параметр, в выводе будут **удаленные и локальные ветки**.

При выполнении этой команды *Git* требуется осуществить определенный порядок действий, чтобы переходить на ветку, которую мы указали. Для этого программа выполняет следующий алгоритм:

Проверка, что указанная нами ветка существует в проекте
Этот этап необходим, так как в ином случае программа не сможет переключиться на ветвь, которая не определена. Для большего понимания нужно вспомнить, что такое ветка в *git*. Учитываем, что фактически задание ветки — это запись коммита, на который она ссылается. Внутри *Git* наличие конкретной ветки проверяется наличием одноименного файла в конкретной директории.

Переключение указателя *HEAD* на новую ветку
Необходимо сместить указатель, чтобы *Git* понимал, где сейчас идет работа.

Изменение рабочей версии таким образом, чтобы новая ветка ей полностью соответствовала
Сама концепция работы ветвления заключается в том, что в разных ветках находятся разные версии кода, над которыми работа ведется отдельно друг от друга. Тогда необходимо изменить рабочую копию. *Git* берет последний коммит и восстанавливает все изменения.

После завершения всех перечисленных выше действий можно считать, что мы полностью переключились. Также с помощью *checkout* можно извлечь отдельный файл (или папку) из другой ветки и получить его, предварительно перейдя в ту ветку, куда вы собираетесь перенести файл. 
* Для этого выполняем: ***git checkout <имя новой ветки>** -- <Путь к папке>*

## *Основы слияния*
Ветвление позволяет разделять рабочий процесс, оптимизировать тестирование и написание нового кода. Однако после того, как разработчик убедился, что написанный им кусок кода готов и его можно отправить к остальной части итоговой версии, удобно переместить его в основную ветку. Такой подход дает возможность получить к концу разработки проекта целый продукт в одном месте.
Для этого в *Git* предусмотрено слияние — перенос изменений с одной ветки на другую. Однако сливаемая ветка (под этим определением мы подразумеваем ветку, у которой берем изменения для _«вливания»_ их в другую ветвь) никак не меняется и остается в прежнем состоянии. 
* Такие преобразования мы получаем, применив *git merge*:
***git merge** <имя сливаемой ветки>*

Операция может привести к появлению конфликтов при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния *Git* останавливает выполнение команды, чтобы вы могли разрешить конфликт.

Также стоит упомянуть о существовании ключей, предназначенных специально для работы с конфликтами:

* abort — прерывает слияние и возвращает все к началу
* continue — продолжает слияние после разрешения конфликта

Решить конфликт можно двумя способами:
1. Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.
2. Выбрать более подходящий файл, а от второго отказаться.


## *Конфликты слияния*
Системы контроля версий предназначены для управления дополнениями, вносимыми в проект множеством распределенных авторов (обычно разработчиков). Иногда один и тот же контент могут редактировать сразу несколько разработчиков. Если разработчик **A** попытается изменить код, который редактирует разработчик **B**, может произойти конфликт. Для предотвращения конфликтов разработчики работают в отдельных изолированных ветках. Основная задача команды *git merge* заключается в слиянии отдельных веток и разрешении любых конфликтующих правок.

Слияние и конфликты являются неотъемлемой частью работы с *Git*. В других инструментах управления версиями, например *SVN*, работа с конфликтами может быть дорогой и времязатратной. *Git* позволяет выполнять слияния очень просто. В большинстве случаев *Git* самостоятельно решает, как автоматически интегрировать новые изменения.

Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях *Git* не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. *Git* помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.

Конфликт во время слияния может произойти в двух отдельных точках — при запуске и во время процесса слияния. Далее рассмотрим, как разрешать каждый из этих конфликтных сценариев.

* ***Git* прерывает работу в самом начале слияния**

Выполнение команды слияния прерывается в самом начале, если *Git* обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. *Git* не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд *git stash*, *git checkout*, *git commit* или *git reset*. **Если команда слияния прерывается в самом начале, выдается следующее сообщение об ошибке: error: Entry '<fileName>' not uptodate. Cannot merge. (Changes in working directory)**

* ***Git* прерывает работу во время слияния**

Сбой **В ПРОЦЕССЕ** слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. *Git* сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы вы разрешили их вручную. **При сбое во время выполнения слияния выдается следующее сообщение об ошибке: error: Entry '<fileName>' would be overwritten by merge. Cannot merge. (Changes in staging area)**

## *Актуализация локального репозитория и контроль веток*

**_Git fetch_** — команда в распределенной системе контроля версий *Git*, которая используется для скачивания изменений из удаленного или локального репозитория в свой локальный репозиторий.

Польза *git fetch* в том, что эта команда привносит актуальность локальному репозиторию без изменения его дерева или текущей ветки. Таким образом, следить за изменениями, сделанными другими участниками, становится проще, быстрее можно начать работу с этими изменениями. 
Если Вы сталкиваетесь с трудностями привязки ветки вашего локального репозитория к удалённому, команда: *git fetch* обновит сведения об удалённом репозитории и в последствии вы сможете осуществить связку веток между собой. Для связи Вы можете использовать команду: **git branch --set-upstream-to=** имя репозитория/имя внешней ветки имя локальной ветки


* Чтобы удалить **локальную** ветку в *Git* нужно выполнить команду:

**_git branch -d_** имя ветки

Обратите внимание на то, что ветка, которую вы удаляете, не должна быть вашей текущей веткой, в которой вы работаете, иначе отобразится ошибка вида:
*error: Cannot delete branch ’mybranch’ checked out at ’/path/to*
Поэтому, если вам нужно удалить текущую ветку, то сначала нужно переключиться на какую-либо другую ветку, а только потом выполнять удаление.

Если вдруг возникает ошибка: *The branch ’mybranch’ is not fully merged. If you are sure you want to delete it* и вы по прежнему хотите удалить ветку, то для принудительного удаления ветки можно воспользоваться опцией **-D**:

**_git branch -D_** имя ветки

* Чтобы удалить **удаленную (находящуюся на удалённом репозитории)** ветку используется команда :

**_git push origin -d_** имя удалённой (*находящейся на удалённом репозитории*) ветки

На этом Мы заканчиваем знакомство с ветвлениями, слияниями и конфликтами.

[def]: https://drive.google.com/file/d/1kz8O_862oZ68E6O84Ew1re8MFrnL_1I1/view?usp=share_link