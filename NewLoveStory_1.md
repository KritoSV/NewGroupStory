# Большая шпаргалка по работке с *Git*, *Git Hub* и *MarkDown*
Оглавление:
1. Подготовка действий для работы с программами. --- **_Rustamoff_**
2. Работа с **_MarkDown_** Тонкости и плюсы. --- **__Shmid__**
3. Начало работы с **Git** в *Visual Studio Code* и немного магии. --- **_Fennellis_**
4. Основные команды в *Git*. --- **_Evgenichka_**
5. [Ветки в *Git* ветвление/слияние/конфликты.](#title5) --- **_KiritoSV_**
6. Начало работы в **_Git Hub_**. --- **_Osman_**
7. Проверка коммитов и веток в **_Git Hub_**, коментарии для участников проекта(Редактирование).
8. Наглядное пособие (контент, доп. программы для упрощения работы разработчика).
9. Работа с удалёнными репозотриями через локалный терминал. --- **_Sofyamamamia_**
10. Как работать в команде ***(Soft skill`s`)***, идеи и трудности.
11. Основные ошибки при работе с *Git*, *Git Hub* и *MarkDown*. --- **_AlionaJe_** 
12. Советы по работе над проектами
13. Немного о *Python* на *Vs Code*
14. Благодарность самим себе и напутствия для остальных!
* Финал *LoveStory*

# <a id="title5">Глава 5. Ветки в *Git* Ветвление/Слияние/Конфликты.</a>

## **Основы ветвления**

Под веткой принято понимать независимую последовательность коммитов в хронологическом порядке. Однако конкретно в *Git* реализация ветки выполнена как указатель на последний коммит в рассматриваемой ветке. После создания ветки уже новый указатель ссылается на текущий коммит.

Имя основной ветки *Git* — проекта по умолчанию — *_master_* (однако зачастую бывает main, например, в *GitHub*), она появляется сразу при инициализации репозитория. Эта ветка ничем не отличается от остальных и также её можно переименовать, но по договоренности *master* принято считать главной веткой в проекте.

Команда **_git branch_** — главный инструмент для работы с ветвлением. С её помощью можно добавлять новые ветки, перечислять и переименовывать существующие и удалять их.

* Чтобы в *Git* добавить ветку мы используем:
    ***git branch** <имя ветки>*

После данной операции ветка уже была создана, но вы по-прежнему находитесь в прежней ветке. 
* Если вы планируете переместиться на другую ветку, в том числе только что созданную, необходимо написать: ***checkout: git checkout** <название ветки>*

Чаще всего при создании новой ветки git пользователю необходимо сразу же переключиться на нее. 
* В таком случае стоит использовать: **git checkout branch** <имя новой ветки>*

* Мы получим тот же результат при использовании *git checkout* с ключом *-b*: ***git checkout -b** <имя ветки>*

Если пользователю нужно получить список определенного множества веток, то тогда можно воспользоваться ключами. 

* Одними из самых распространенных будут:

*-r* — при использовании этого ключа мы получим **список удаленных вето**к;

*-a* — используя этот параметр, в выводе будут **удаленные и локальные ветки**.

При выполнении этой команды *Git* требуется осуществить определенный порядок действий, чтобы переходить на ветку, которую мы указали. Для этого программа выполняет следующий алгоритм:

Проверка, что указанная нами ветка существует в проекте
Этот этап необходим, так как в ином случае программа не сможет переключиться на ветвь, которая не определена. Для большего понимания нужно вспомнить, что такое ветка в *git*. Учитываем, что фактически задание ветки — это запись коммита, на который она ссылается. Внутри *Git* наличие конкретной ветки проверяется наличием одноименного файла в конкретной директории.

Переключение указателя *HEAD* на новую ветку
Необходимо сместить указатель, чтобы *Git* понимал, где сейчас идет работа.

Изменение рабочей версии таким образом, чтобы новая ветка ей полностью соответствовала
Сама концепция работы ветвления заключается в том, что в разных ветках находятся разные версии кода, над которыми работа ведется отдельно друг от друга. Тогда необходимо изменить рабочую копию. Git берет последний коммит и восстанавливает все изменения.

После завершения всех перечисленных выше действий можно считать, что мы полностью переключились. Также с помощью *checkout* можно извлечь отдельный файл (или папку) из другой ветки и получить его, предварительно перейдя в ту ветку, куда вы собираетесь перенести файл. 
* Для этого выполняем: ***git checkout <имя новой ветки>** -- <Путь к папке>*

## Основы ветвления и слияния
Ветвление позволяет разделять рабочий процесс, оптимизировать тестирование и написание нового кода. Однако после того, как разработчик убедился, что написанный им кусок кода готов и его можно отправить к остальной части итоговой версии, удобно переместить его в основную ветку. Такой подход дает возможность получить к концу разработки проекта целый продукт в одном месте.
Для этого в *Git* предусмотрено слияние — перенос изменений с одной ветки на другую. Однако сливаемая ветка (под этим определением мы подразумеваем ветку, у которой берем изменения для _«вливания»_ их в другую ветвь) никак не меняется и остается в прежнем состоянии. 
* Такие преобразования мы получаем, применив *git merge*:
***git merge** <имя сливаемой ветки>*

Операция может привести к появлению конфликтов при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния Git останавливает выполнение команды, чтобы вы могли разрешить конфликт.

Также стоит упомянуть о существовании ключей, предназначенных специально для работы с конфликтами:

* abort — прерывает слияние и возвращает все к началу
* continue — продолжает слияние после разрешения конфликта

Решить конфликт можно двумя способами:
1. Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.
2. Выбрать более подходящий файл, а от второго отказаться.


## Конфликты слияния
Системы контроля версий предназначены для управления дополнениями, вносимыми в проект множеством распределенных авторов (обычно разработчиков). Иногда один и тот же контент могут редактировать сразу несколько разработчиков. Если разработчик **A** попытается изменить код, который редактирует разработчик **B**, может произойти конфликт. Для предотвращения конфликтов разработчики работают в отдельных изолированных ветках. Основная задача команды *git merge* заключается в слиянии отдельных веток и разрешении любых конфликтующих правок.

Слияние и конфликты являются неотъемлемой частью работы с *Git*. В других инструментах управления версиями, например *SVN*, работа с конфликтами может быть дорогой и времязатратной. *Git* позволяет выполнять слияния очень просто. В большинстве случаев *Git* самостоятельно решает, как автоматически интегрировать новые изменения.

Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях *Git* не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. *Git* помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.

Конфликт во время слияния может произойти в двух отдельных точках — при запуске и во время процесса слияния. Далее рассмотрим, как разрешать каждый из этих конфликтных сценариев.

* ***Git* прерывает работу в самом начале слияния**

Выполнение команды слияния прерывается в самом начале, если *Git* обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. *Git* не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд *git stash*, *git checkout*, *git commit* или *git reset*. **Если команда слияния прерывается в самом начале, выдается следующее сообщение об ошибке: error: Entry '<fileName>' not uptodate. Cannot merge. (Changes in working directory)**

* ***Git* прерывает работу во время слияния**

Сбой **В ПРОЦЕССЕ** слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. *Git* сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы вы разрешили их вручную. **При сбое во время выполнения слияния выдается следующее сообщение об ошибке: error: Entry '<fileName>' would be overwritten by merge. Cannot merge. (Changes in staging area)**


### ***Заключение по главе***

*Git* обладает множеством преимуществ по сравнению с другими системами контроля версий как раз из-за легковесной работы с ветвлением. Такая гибкость помогает максимально оптимизировать процесс разработки. А само ветвление сильно упрощает разработку проекта. Ветки обеспечивают безопасный совместный доступ к коду для разных людей. Ведь именно они дают возможность пластично и изящно работать над созданием нового продукта.